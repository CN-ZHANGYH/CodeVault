(window.webpackJsonp=window.webpackJsonp||[]).push([[188],{501:function(t,v,_){"use strict";_.r(v);var e=_(7),i=Object(e.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"kvm-虚拟化技术"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#kvm-虚拟化技术"}},[t._v("#")]),t._v(" KVM 虚拟化技术")]),t._v(" "),v("h3",{attrs:{id:"kvm-简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#kvm-简介"}},[t._v("#")]),t._v(" KVM 简介")]),t._v(" "),v("p",[t._v("​    "),v("code",[t._v("KVM（Kernel-based Virtual Machine，基于内核的虚拟机）是一种内建于 Linux 中的开源虚拟化技术。")]),t._v("具体而言，KVM 可帮助用户将 Linux 转变为虚拟机监控程序，使主机计算机能够运行多个隔离的虚拟环境，即虚拟客户机或虚拟机（VM）。")]),t._v(" "),v("p",[t._v("​    "),v("code",[t._v("KVM 是 Linux 的一部分，Linux2.6.20 或更新版本包括 KVM。")]),t._v("KVM 于 2006 年首次公布，并在一年后合并到主流 Linux 内核版本中。由于 KVM 属于现有的 Linux 代码，因此它能立即享受每一项新的 Linux 功能、修复和发展，无需进行额外工程。")]),t._v(" "),v("h3",{attrs:{id:"kvm-功能特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#kvm-功能特性"}},[t._v("#")]),t._v(" KVM 功能特性")]),t._v(" "),v("p",[v("strong",[t._v("1. 内存管理")])]),t._v(" "),v("p",[t._v("​    "),v("code",[t._v("KVM 从 Linux 继承了强大的内存管理功能。")]),t._v("一个虚拟机的内存与任何其他 Linux 进程的内存一样进行存储，可以以大页面的形式进行交换以实现更高的性能，也可以以磁盘文件的形式进行共享。NUMA（Non-Uniform Memory Access，非一致存储访问结构）很好地解决了CPU 资源的扩展问题，它可以把几十个甚至上百个 CPU 组合在一个服务器内，支持非一致性内存访问，针对多处理器的内存设计，允许虚拟机有效地访问大量内存。")]),t._v(" "),v("p",[t._v("​    KVM 支持最新的基于硬件的内存虚拟化功能，支持 Intel 的扩展页表（EPT）和 AMD 的嵌套页表（NPT，也叫“快速虚拟化索引-RVI”），以实现更低的 CPU 利用率和更高的吞吐量。内存页面共享通过一项名为内核同页合并（KernelSame-pageMerging，KSM）的内核功能来支持。KSM 扫描每个虚拟机的内存，如果虚拟机拥有相同的内存页面，KSM 将这些页面合并到一个在虚拟机之间共享的页面，仅存储一个副本。如果一个客户机尝试更改这个共享页面，它将得到自己的专用副本。")]),t._v(" "),v("p",[v("strong",[t._v("2. 存储")])]),t._v(" "),v("p",[t._v("​    "),v("code",[t._v("KVM 能够使用 Linux 支持的任何存储来存储虚拟机镜像")]),t._v("，包括具有 IDE、SCSI 和 SATA 的本地磁盘，网络附加存储 NAS（包括 NFS 和 SAMBA/CIFS）或者支持 iSCSI 和光纤通道的")]),t._v(" "),v("p",[t._v("SAN。多路径 I/O 可用于改进存储吞吐量和提供冗余。由于 KVM 是 Linux 内核的一部分，它可以利用所有领先存储供应商都支持的一种成熟且可靠的存储基础架构，它的存储堆栈在生产部署方面具有良好的记录。")]),t._v(" "),v("p",[t._v("​    KVM 还支持全局文件系统（GFS2）等共享文件系统上的虚拟机镜像，以允许虚拟机镜像在多个宿主之间共享或使用逻辑卷共享。磁盘镜像支持按需分配，仅在虚拟机需要时分配存储空间，而不是提前分配整个存储空间，提高存储利用率。"),v("code",[t._v("KVM 的原生磁盘格式为 QCOW2，它支持快照，允许多级快照、压缩和加密。")])]),t._v(" "),v("p",[v("strong",[t._v("3.设备驱动程序")])]),t._v(" "),v("p",[t._v("​    "),v("code",[t._v("KVM 支持混合虚拟化")]),t._v("，其中准虚拟化的驱动程序安装在客户机操作系统中，允许虚拟机使用优化的 I/O 接口而不使用模拟的设备，从而为网络和块设备提供高性能的 I/O。KVM 准虚拟化的驱动程序使用 IBM 和 RedHat（红帽）联合 Linux 社区开发的 VirtIO 标准，它是一个与虚拟机管理程序独立的、构建设备驱动程序的接口，允许为多个虚拟机管理程序使用一组相同的设备驱动程序，能够实现更出色的虚拟机交互性。")]),t._v(" "),v("p",[v("strong",[t._v("4.性能和可伸缩性")])]),t._v(" "),v("p",[t._v("​    KVM 也继承了 Linux 的性能和可伸缩性。KVM 虚拟化性能在很多方面（如计算能力、网络带宽等）已经可以达到非虚拟化原生环境的95%以上的性能。KVM的扩展性也非常良好，客户机和宿主机都可以支持非常多的 CPU 数量和大量的内存。")]),t._v(" "),v("h3",{attrs:{id:"kvm-架构及相关组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#kvm-架构及相关组件"}},[t._v("#")]),t._v(" KVM 架构及相关组件")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/cn-zhangyh/image/main/img/202204111246811.png",alt:"image-20220209154554044"}})]),t._v(" "),v("p",[t._v("KVM架构如图，左侧部分是一个标准的Linux操作系统，可以是RHEL、CentOS、Ubuntu 等。KVM 内核模块在运行时，按需加载进入内核空间运行。KVM 本身不执行任何设备模拟，需要用户空间程序 QEMU 通过/dev/kvm 接口设置一个虚拟客户机的地址空间，向它提供模拟的 I/O 设备，并将它的视频显示映射回宿主机的显示屏。")]),t._v(" "),v("p",[v("strong",[t._v("1.")]),t._v(" "),v("strong",[t._v("KVM")]),t._v(" 模块")]),t._v(" "),v("p",[t._v("​    "),v("code",[t._v("KVM 模块是 KVM 虚拟机的核心部分。")]),t._v("KVM 仅支持硬件虚拟化。其主要功能是初始化CPU 硬件，打开虚拟化模式，然后将虚拟客户机运行在虚拟机模式下，并对虚拟客户机的运行提供一定的支持。")]),t._v(" "),v("p",[t._v("​    以 KVM 在 Intel 的 CPU 上运行为例，在被内核加载的时候，KVM 模块会先初始化内部的数据结构；之后 KVM 模块检测系统当前的 CPU，然后打开 CPU 控制寄存器 CR4 中的虚拟化模式开关，并通过执行 VMXON 指令将宿主操作系统置于虚拟化模式的根模式；最后 KVM 模块创建特殊设备文件/dev/kvm，并等待来自用户空间的命令。接下来虚拟机的创建和运行是一个用户空间程序（QEMU）和 KVM 模块互相配合的过程。")]),t._v(" "),v("p",[v("strong",[t._v("2.")]),t._v(" "),v("strong",[t._v("QEMU")])]),t._v(" "),v("p",[t._v("​    "),v("code",[t._v("QEMU 是一个开源的虚拟机纯软件的实现，性能低下。")]),t._v("但是其优点是支持本身编译运行的平台上就可以实现虚拟机的功能，甚至虚拟机可以与宿主机不同架构。QEMU 代码中有着整套虚拟机的实现，包括处理器、内存虚拟化以及虚拟设备模拟（比如网卡、显卡、存储控制器及硬盘等）。")]),t._v(" "),v("p",[t._v("​    虚拟机运行期间，QEMU 会通过 KVM 模块提供的系统接口调用进入内核，由 KVM 模块将虚拟机至于处理器的特殊模式运行。遇到虚拟机输入输出操作，KVM 模块会从上次系统调用的接口返回给 QEMU，由 QEMU 来负责解析和处理这些设备。从 QEMU 角度看， QEMU 使用了 KVM 模块的虚拟化功能，为自己的虚拟机提供硬件虚拟化的加速，极大提高虚拟机的性能。虚拟机的配置和创建，运行依赖的虚拟设备、用户操作环境和交互，以及一些特殊功能（如动态迁移），都是由 QEMU 自己实现的。QEMU 和 KVM 模块两者的结合无疑是最合适的选择。而 qemu-kvm 是为了 KVM 专门做了修改和优化的 QEMU 分支。")]),t._v(" "),v("p",[v("strong",[t._v("3.")]),t._v(" "),v("strong",[t._v("Libvirt")])]),t._v(" "),v("p",[t._v("​    Libvirt 是 KVM 的管理工具。Libvirt 除了能管理 KVM 这种 Hypervisor，还能管理 Xen，VirtualBox 等，OpenStack 底层也使用 Libvirt。")]),t._v(" "),v("p",[t._v("Libvirt 包含：后台 Daemon 程序 libvirtd、API 库和命令行工具 virsh。")]),t._v(" "),v("p",[t._v("⚫ **libvirtd：**服务程序，接收和处理 API 请求；")]),t._v(" "),v("p",[t._v("⚫ **API 库：**使得其他人可以开发基于 Libvirt 的高级工具，比如 virt-manager，是图形化的KVM 管理工具；")]),t._v(" "),v("p",[t._v("⚫ **virsh：**是人们经常要用的 KVM 命令行工具，后面小节内容会有使用的示例。")]),t._v(" "),v("p",[t._v("作为 KVM和 OpenStack 的实施人员，virsh 或 virt-manager 是一定要学会使用的。 通常可选择使用命令工具 virsh 替代图形界面的 virt-manager 工具，virsh 常用命令见表")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("命令")]),t._v(" "),v("th",[t._v("解释")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("virsh  define DomainName.xml")]),t._v(" "),v("td",[t._v("通过配置文件定义一个虚拟机")])]),t._v(" "),v("tr",[v("td",[t._v("virsh  create DomainName.xml")]),t._v(" "),v("td",[t._v("创建虚拟机")])]),t._v(" "),v("tr",[v("td",[t._v("virsh edit  DomainName")]),t._v(" "),v("td",[t._v("修改测试 KVM 的配置文件")])]),t._v(" "),v("tr",[v("td",[t._v("virsh list  --all")]),t._v(" "),v("td",[t._v("查看虚拟机的状态")])]),t._v(" "),v("tr",[v("td",[t._v("virsh  dominfo DomainName")]),t._v(" "),v("td",[t._v("显示虚拟机的基本信息")])]),t._v(" "),v("tr",[v("td",[t._v("virsh  domname 2")]),t._v(" "),v("td",[t._v("显示 id 号为 2  的虚拟机名")])]),t._v(" "),v("tr",[v("td",[t._v("virsh  domid DomainName")]),t._v(" "),v("td",[t._v("显示虚拟机 id 号")])]),t._v(" "),v("tr",[v("td",[t._v("virsh  domuuid DomainName")]),t._v(" "),v("td",[t._v("显示虚拟机的 uuid")])]),t._v(" "),v("tr",[v("td",[t._v("virsh  domstate DomainName")]),t._v(" "),v("td",[t._v("显示虚拟机的当前状态")])]),t._v(" "),v("tr",[v("td",[t._v("virsh  dumpxml DomainName")]),t._v(" "),v("td",[t._v("显示虚拟机的当前配置文件")])]),t._v(" "),v("tr",[v("td",[t._v("virsh save  DomainName a")]),t._v(" "),v("td",[t._v("将该虚拟机的运行状态存储到文件 a 中")])]),t._v(" "),v("tr",[v("td",[t._v("virsh  undefine DomainName")]),t._v(" "),v("td",[t._v("移除虚拟机，虚拟机处于关闭状态后还可以启动，但是被该指令删除后不能启动。在虚拟机处于 Running 状态时，调用该指令，该指令暂时不生效。但是当虚拟机被关闭后，该指令生效移除该虚拟机，也可以在该指令生效之前调用  define+TestKVM.xml 取消该指令")])]),t._v(" "),v("tr",[v("td",[t._v("virt-clone  -o DomainName -n   DomainName01  –file   /data/DomainName01.img")]),t._v(" "),v("td",[t._v("在-o 后面为被克隆虚拟机名称，-n  后为克隆所得虚拟机名称，file  为克隆所得虚拟机镜像存放地址。克隆的好处在于，假如在一个虚拟机上安装了操作系统和一些软件，那么从他克隆所得的虚拟机也有一样的系统和软件，大大节约了重新安装虚拟机的时间")])])])]),t._v(" "),v("h3",{attrs:{id:"kvm-的网络模型概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#kvm-的网络模型概述"}},[t._v("#")]),t._v(" KVM 的网络模型概述")]),t._v(" "),v("p",[t._v("​    KVM 虚拟化使用一种称为虚拟交换的技术实现虚拟机的网络互联，虚拟交换是运行在宿主机上的一个软件结构，虚拟主机通过这个虚拟交换进行直连，实现与外界通信。虚拟交换可以运行在 NAT 模式、路由模式等。见表描述了这些模式的特性和功能：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("模式")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("功能")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("隔离模型")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("虚拟机之间组建网络，该模式无法与宿主机通信，无法与其他网络通信，相当于虚拟机只是连接到一台交换机上")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("NAT 模式")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("该模式网桥要作为路由器对虚拟机地址进行转发，路由模式是无法修改源地址 IP，因此虚拟机可能会成功地将报文发送给目标地址 IP，而目标地址 IP 无法将报文回传给源地址 IP")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("路由模型")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("相当于虚拟机连接到一台路由器上，由路由器（物理网卡），统一转发，但是不会改变源地址")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("桥接模型")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("在该模式下，宿主机会虚拟出来一张虚拟网卡作为宿主机本身的通信网卡，而宿主机的物理网卡则成为桥设备（交换机），所以虚拟机相当于在宿主机所在局域网内的一个单独的主机，它的行为和宿主机是同等地位的，没有依存关系")])])])])])}),[],!1,null,null,null);v.default=i.exports}}]);